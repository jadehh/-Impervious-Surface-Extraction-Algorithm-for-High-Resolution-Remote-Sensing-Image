# coding=utf-8from PIL import Imagefrom pylab import *from PyQt4 import QtGuidef extract_features(in_file):    im = array(Image.open(in_file))    X = im.shape[0]    Y = im.shape[1]    features = []    for i in range(X):        for j in range(Y):            R = im[i, j, 0]            G = im[i, j, 1]            B = im[i, j, 2]            features.append([R, G, B])    features = array(features, 'f')    return features# 聚类出来的图像不同类别用颜色区分出来def EX_Fenge(code, in_file, k):    fanwei = []    if k == 2 or k == 3 :        fanwei = [0]    elif k == 5 or k==4:        fanwei = [0,1]    elif k == 6:        fanwei = [0, 1]    elif k == 7:        fanwei = [0, 1, 6]    elif k==8:        fanwei = [0, 1,7]    elif k == 9:        fanwei = [0, 1,8]    predict_label = code    im = array(Image.open(in_file))    image_shape = im.shape[:2]    X = image_shape[0]    Y = image_shape[1]    TestData = np.zeros((X * Y, 3))    # R,G,B分量    # 定义几种颜色[紫色,白色,青色,黑色,绿色,蓝色,红色,黄色,粉色]    for run in range(X * Y):        if (predict_label[run] in fanwei):            if (predict_label[run] in fanwei):                TestData[run, 0] = 1                TestData[run, 1] = 1                TestData[run, 2] = 1            else:                TestData[run, 0] = 0                TestData[run, 1] = 0                TestData[run, 2] = 0    result = np.zeros((X, Y, 3))  # RGB彩色图像    run = 0    for i in range(X):        for j in range(Y):            result[i, j, 0] = TestData[run, 0]            result[i, j, 1] = TestData[run, 1]            result[i, j, 2] = TestData[run, 2]            run = run + 1    return result# 矩阵转成图像def MatrixToImage(data):    data = data * 255    new_im = Image.fromarray(data.astype(np.uint8))    return new_imdef PilToPixMap(filename,I):    I = MatrixToImage(I)    I.save(filename)    PixMap = QtGui.QPixmap(filename)    return PixMap#每个像素的颜色特征def extract_Yanshan(infile):    I = array(Image.open(r'C:\Users\Administrator\Desktop\yanshan.tif'))    R = I[:, :, 0]    G = I[:, :, 1]    B = I[:, :, 2]    # %灰度值归一化    R = double(R) / (255)    G = double(G) / (255)    B = double(B) / (255)    M = shape(R)[0]    N = shape(R)[1]    R = reshape(R, [1, M * N])    G = reshape(G, [1, M * N])    B = reshape(B, [1, M * N])    p = np.row_stack((R, G, B))    p = np.transpose(p)    p_test = p.tolist()    return p_testdef extract_GLCM_Yanshan(infile):    I = array(Image.open(r'C:\Users\Administrator\Desktop\yanshan.tif'))    R = I[:, :, 0]    G = I[:, :, 1]    B = I[:, :, 2]    # %灰度值归一化    R = double(R) / (255)    G = double(G) / (255)    B = double(B) / (255)    M = shape(R)[0]    N = shape(R)[1]    R = reshape(R, [1, M * N])    G = reshape(G, [1, M * N])    B = reshape(B, [1, M * N])    p = np.row_stack((R, G, B))    p = np.transpose(p)    p_test = p.tolist()    return p_testdef minmax(data):    P_minmax = []    for i in range(data.shape[1]):        P_minmax.append([data[:, i].min(), data[:, i].max()])    return P_minmax